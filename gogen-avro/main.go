package main

import (
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"sort"

	"github.com/clear-street/gogen-avro/generator"
	"github.com/clear-street/gogen-avro/imprt"
	"github.com/clear-street/gogen-avro/schema"
)

const (
	comment = "// Code generated by github.com/clear-street/gogen-avro. DO NOT EDIT."
)

func main() {
	cfg := parseCmdLine()

	namespace := schema.NewNamespace(cfg.shortUnions)

	switch cfg.namespacedNames {
	case nsShort:
		generator.SetNamer(generator.NewNamespaceNamer(true))
	case nsFull:
		generator.SetNamer(generator.NewNamespaceNamer(false))
	}

	for _, fileName := range cfg.files {
		schema, err := ioutil.ReadFile(fileName)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error reading file %q - %v\n", fileName, err)
			os.Exit(2)
		}

		_, err = namespace.TypeForSchema(schema)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error decoding schema for file %q - %v\n", fileName, err)
			os.Exit(3)
		}
	}

	for _, v := range namespace.Schemas {
		if err := v.Root.ResolveReferences(namespace); err != nil {
			panic(err)
		}
	}

	sortedDefs := make([]schema.QualifiedName, 0, len(namespace.Definitions))
	for k, _ := range namespace.Definitions {
		sortedDefs = append(sortedDefs, k)
	}
	sort.Sort(schema.QualifiedNameList(sortedDefs))

	pkgs := map[string]*generator.Package{}
	pkgsList := make([]string, 0)
	for _, k := range sortedDefs {
		v := namespace.Definitions[k]
		pkg, ok := pkgs[k.Namespace]
		if !ok {
			pkg = generator.NewPackage(cfg.packageName, k.Namespace)
			pkgs[k.Namespace] = pkg
			pkgsList = append(pkgsList, k.Namespace)
		}

		v.AddStruct(pkg, true)
		v.AddSerializer(pkg)
	}

	commented := map[string]bool{}
	for _, k := range pkgsList {
		v := pkgs[k]
		path := filepath.Join(cfg.targetDir, imprt.Pkg(cfg.packageName, k))
		if imprt.IsRootPkg(cfg.packageName, k) {
			path = cfg.targetDir
		}

		if err := os.MkdirAll(path, os.ModePerm); err != nil {
			panic(err)
		}

		for _, f := range v.Files() {
			n := v.Name() + f
			if _, ok := commented[n]; ok {
				continue
			}
			v.AddHeader(f, comment)
			commented[n] = true
		}

		err := v.WriteFiles(path)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error writing source files to directory %q - %v\n", path, err)
			os.Exit(4)
		}
	}
}
