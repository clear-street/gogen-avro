package main

import (
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"sort"

	"github.com/clear-street/gogen-avro/generator"
	"github.com/clear-street/gogen-avro/imprt"
	"github.com/clear-street/gogen-avro/types"
)

const (
	comment = "// Code generated by github.com/clear-street/gogen-avro. DO NOT EDIT."
)

func main() {
	packageName := flag.String("package", "avro", "Root package")
	containers := flag.Bool("containers", false, "Whether to generate container writer methods")
	shortUnions := flag.Bool("short-unions", false, "Whether to use shorter names for Union types")

	flag.Parse()
	if flag.NArg() < 2 {
		fmt.Fprintf(os.Stderr, "Usage: gogen-avro [--short-unions] [--package=<root package>] [--containers] <target directory> <schema files>\n")
		os.Exit(1)
	}

	targetDir := flag.Arg(0)
	files := flag.Args()[1:]
	namespace := types.NewNamespace(*shortUnions)

	for _, fileName := range files {
		schema, err := ioutil.ReadFile(fileName)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error reading file %q - %v\n", fileName, err)
			os.Exit(2)
		}

		_, err = namespace.TypeForSchema(schema)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error decoding schema for file %q - %v\n", fileName, err)
			os.Exit(3)
		}
	}

	for _, v := range namespace.Schemas {
		if err := v.Root.ResolveReferences(namespace); err != nil {
			panic(err)
		}
	}

	sortedDefs := make([]types.QualifiedName, 0, len(namespace.Definitions))
	for k, _ := range namespace.Definitions {
		sortedDefs = append(sortedDefs, k)
	}
	sort.Sort(types.QualifiedNameList(sortedDefs))

	pkgs := map[string]*generator.Package{}
	pkgsList := make([]string, 0)
	for _, k := range sortedDefs {
		v := namespace.Definitions[k]
		pkg, ok := pkgs[k.Namespace]
		if !ok {
			pkg = generator.NewPackage(*packageName, k.Namespace)
			pkgs[k.Namespace] = pkg
			pkgsList = append(pkgsList, k.Namespace)
		}

		v.AddStruct(pkg, *containers)
		v.AddSerializer(pkg)
		v.AddDeserializer(pkg)
	}

	commented := map[string]bool{}
	for _, k := range pkgsList {
		v := pkgs[k]
		path := filepath.Join(targetDir, imprt.Pkg(*packageName, k))
		if imprt.IsRootPkg(*packageName, k) {
			path = targetDir
		}

		if err := os.MkdirAll(path, os.ModePerm); err != nil {
			panic(err)
		}

		for _, f := range v.Files() {
			n := v.Name() + f
			if _, ok := commented[n]; ok {
				continue
			}
			v.AddHeader(f, comment)
			commented[n] = true
		}

		err := v.WriteFiles(path)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error writing source files to directory %q - %v\n", path, err)
			os.Exit(4)
		}
	}
}
